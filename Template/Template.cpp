#include <iostream>
using namespace std;

// Шаблонные функции 
/*
template <typename T>
typename может быть назван class
 Шаблонная функция суммы двух чисел, но тип принимаего значения не определен изначально, т.е. тип может быть как double, так и float и т.д.
 Но в такое случае принимаемы значения в функции должны быть одинаковы, т.е. int, int; double, double;
 Т.к. переменная T шаблонного типа не может быть разных типов.

 T Sum(T a, T b) {

	retun a + b;

}

 Если мы хотим, чтобы параметры могли быть разными, нужно сделать следующее:

 template <typename T, typename T1>

 Тогда, если мы будем создавать функцию Sum, то тип возращаемого и принимаего значения определяем сами:

 T1 Sum(T a, T1 b)

 Но в таком случае вернется число типа T1 в данном случаем.


 */

// Шаблоны классов
template<typename T> // Эта запись значит то, что в MyClass мы будем использовать какой-то неизвестный тип данных.

/*
Ключевое слово template говорит, что MyClass будет шаблонным.
typename (можно также указать class)- указываает на то, что будут использоваться обобщенные типы данных.
T - название обобщенного типа данных.

T - может быть как принимаемы параметром, так и возращаемым.
*/

class MyClass
{
public:
	MyClass(T value) {

		this->value = value;

	}
	
	void DataTypeSize() {

		cout << sizeof(value) << endl;
	}

private:
	T value; // Перменная value типа T
};

class Point
{

public:
	
	Point() { // Конструктор

		x = y = z = 0;
	}
	Point(int x, int y, int z) {
		this->x = x;
		this->y = y;
		this->z = z;
	 }
	int x;
	int y;
	int z;
};

int main()
{

    // При объвлении шаблонного класса, мы должны указать ему с каким типом данных он будет работать.
	
	/*
	Т.к. изначально в MyClass хранится шаблонная переменная типа T, то когда мы вызовем метод класса DataTypeSize, а передастся туда значение типа int,
	то с этого момента в MyClass переменная T станет типом int.

	Также в качестве типа данных при объявлении класса, мы также может передать другой класс.

	Имеем класс Point: 

	class Point
	{
		public:
			int x, y, z;
		Point() { // Конструктор

			x = y = z = 0;
		}
		Point(int x, int y, int z) {
		this->x = x;
		this->y = y;
		this->z = z;
		}
	};

	T - может быть как принимаемы параметром, так и возращаемым.
	*/
	Point a;
	MyClass<Point> c(a);
	c.DataTypeSize();
}


